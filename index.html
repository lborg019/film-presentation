<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Clustered MongoDB Slides</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/black.css">

		<!-- Theme used for syntax highlighting of code -->
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<!-- Printing and PDF exports -->
		<script>
			var link = document.createElement( 'link' );
			link.rel = 'stylesheet';
			link.type = 'text/css';
			link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
			document.getElementsByTagName( 'head' )[0].appendChild( link );
		</script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">
				<section data-markdown> <!-- Opening -->
					<script type="text/template">
					## MongoDB Sharded Clusters on Docker Networks
					<h4>Using docker-compose, bash scripts and healthchecks</h4>

					<p>Lukas Borges: FIU // Software Engineer, All Now Corp</p>
					<p>lborges@allnowcorp.com // [github/lborg019](http://github.com/lborg019)</p>
					</script>
				</section>
				<section data-markdown>
					<script type="text/template">
						## Overview
						<!-- A paragraph with some text and a [link](http://hakim.se). -->
						<section>What is MongoDB?</section>
            			<section>What is Docker?</section>
						<section>How to Combine Both?</section>
					</script>
				</section>
				<section data-background-image="./ht/imgs/mongodb.png" data-background-size="400px"> <!-- MongoDB Secgion -->
					What is MongoDB?</br>
					<ul>
					<li>MongoDB</li>
					<li>Sharding</li>
					<li>Basic Commands</li>
					<li>Plan of Attack</li>
					<li>How to Shard?</li>

					</ul>
				</section>
				<section data-markdown>
					<script type="text/template">
						<section>MongoDB is a NoSQL document-oriented database.</section>
						<section>Mongo uses JSON-like documents with schemas, instead of tables and rows (as in relational databases).</section>
						<section>Hierarchy:</br>
							Infrastructure / MongoDB / Databases / Collections / JSON Data
						</section>
						<section data-background-image="./ht/imgs/hierarchy.png" data-background-size="600px">
						</section>
						<section>
							MongoDB Data:</br>
								<pre class="stretch"><code data-trim data-noescape>
								{
									"_id" : ObjectId("584326f4de11cc88bee98b89"),
									"electionname" : "Presidential election",
									"state" : "all",
									"route" : "presidential",
									"candidates" : [ 
										{
											"name" : "Bernie Sanders",
											"party" : "Democratic",
											"avatar" : "./app-content/avatars/bernie_blue.svg",
											"votes" : 4
										}, 
										{
											"name" : "Donald Trump",
											"party" : "Republican",
											"avatar" : "./app-content/avatars/trump_pink.svg",
											"votes" : 2
										}]
								}
								</code></pre>
						</section>
						<section>
							Basic MongoDB commands:
							<pre><code data-trim data-noescape>
							$ mongo $ip:$port
							$ show dbs
							$ use $databasename
							$ show collections
							$ db.$collectionname.insert({$jsondata})
							$ db.getCollections('$collectionname').find({})
							</code></pre>
						</section>
						<section>Mongo Shards</section>
						<section>Instead of writing your data to a single collection, Mongo can scatter your data along different servers when writing, and gather it when reading.</section>
						<section data-background-image="./ht/imgs/sharded-collection2.png" data-background-size="600px">
						</section>
						<section>Reasons for Sharding:</section>
						<section>
						Performance: By spreading the data, reads and writes are distributed among nodes in the cluster. Combined with bulk writes, we improve system's overall performance.
						</section>
						<section>
						Security: If a hacker gains access to one of the shards, he will only have partial data. If data is encrypted, even safer.
						</section>
						<section>
						Persistence: If a hacker takes down a shard, a replica can automatically be deployed. Two replicas per shard is usually enough
						</section>
						<section>
						Integration: System is "invisible". Application will read and write to the database like in any regular MongoDB. The system will take care of the scatter/gather steps in the cluster.
						</section>
						<section>
						How to create a sharded cluster in MongoDB?
						</section>
						<section>
							Step 1) All nodes in our cluster must be online
						</section>
							<section data-background-image="./ht/imgs/plan-of-attack3.png" data-background-size="800px">
							</section>
						<section>
							Step 2) Start the three config servers with the following command:
							<pre><code data-trim data-noescape>
								$ mongod --configsvr --dbpath /mongo-metadata --port 27019
							</code></pre>
						</section>
						<section>
							Step 3) Start the router server with the following command:
							<pre><code data-trim data-noescape>
								$ mongos --configdb
								config0.example.com:27019,
								config1.example.com:27019,
								config2.example.com:27019
							</code></pre>
						</section>
						<section>
							Step 4) Access the router, add shards to the cluster:
							<pre><code data-trim data-noescape>
								$ sh.addShard("shard0.example.com:27017")
								$ sh.addShard("shard1.example.com:27017")
								$ sh.addShard("shard1.example.com:27017")
							</code></pre>
						</section>
						<section>
							Step 5) Still in the Router, add replica sets to the cluster:
							<pre><code data-trim data-noescape>
								$ sh.addShard("rs1/shard0.example.com:27017")
								$ sh.addShard("rs2/shard1.example.com:27017")
							</code></pre>
						</section>
						<section>
							Step 6) Enable Sharding on the Database Level
							<pre><code data-trim data-noescape>
								$ show dbs
								$ use dbname
								$ sh.enableSharding("dbname")
							</code></pre>
						</section>
						
						<section>
							Step 7) Define shard key (strategy). If unsure about data distribution, or (inexistent) hash the _id field.
							<pre><code data-trim data-noescape>
								$ use dbname
								$ db.dbname_collection.ensureIndex({ _id: "hashed" })
							</code></pre>
						</section>

						<section>
							Step 8) Define shard key (strategy). If unsure about data distribution, or (inexistent) hash the _id field.
							<pre><code data-trim data-noescape>
								$ sh.shardCollection("dbname.dbname_collection", { "_id":"hashed" }) 
							</code></pre>
							And we are ready to insert data.
						</section>

						<section>
						Plan of Attack
						</section>
							<section>
							We will use multiple *Docker* containers running MongoDB networked together to create our cluster
							</section>
							<section data-background-image="./ht/imgs/plan-of-attack3.png" data-background-size="800px">
							</section>
						</section>
					</script>
				</section>
				<!-- docker -->
				<section data-background-image="./ht/imgs/docker-logo.png" data-background-size="500px">
					What is Docker?<br>
					<ul>
					<li>Docker Hub</li>
					<li>Dockerfile</li>
					<li>Dockercompose</li>
					</ul>
				</section>
				<section data-markdown>
					<script type="text/template">
					<section>
					Docker containers wrap a piece of software in a complete filesystem that contains everything needed to run: code, runtime, system tools, system libraries - anything that can be installed on a server.
					This guarantees that the software will always run the same, regardless of its environment.
					</section>
					<section>Virtual Machine vs. Docker:</section>
					<section data-background-image="./ht/imgs/vmvscont.png" data-background-size="1300px">
					</section>
					<section> 
					Installing Docker:
					[docker.com/products/overview](https://docker.com/products/overview) </br>
					Latest Docker installer comes bundled with Docker Compose and Docker Machine, making Docker Toolbox obsolete.</br>
					Bash completion for Docker makes things easier.</br>
					<img src="./ht/imgs/docker-toolbox.png" width="40%">
					</section>
					<section>
						Basic Docker Commands
						<pre><code data-trim data-noescape>
						$ docker run $image 
						$ docker start $name|$id
						$ docker stop $name|$id
						$ docker ps [-a include stopped containers]
						$ docker rm $name|$id
						$ docker images
						</code></pre>

					</section>
					<section>
						Docker Hub
					</section>
					<section>
						Official Docker images are hosted in Docker Hub (much like Github).</br>
						Users can pull official releases of images from the Docker Hub repository and run them
					</section>
					<section data-background-image="./ht/imgs/dockerhub.png" data-background-size="800px">

					</section>
					<section>
						Running:
						<pre><code data-trim data-noescape>
  						$ docker run tutum/hello-world
						</code></pre>
						If absent, downloads the image from Docker Hub and runs it.
					</section>
					<section>
						Users can run container processes detached, or interactively.
					</section>
					<section>
						Users can expose and map internet ports between container and host.
					</section>
					<section>
						Users can mount host's files and folders to container.
					</section>
					<section>
						Dockerfile
					</section>
					<section>
						Users will often need more than a pre-built with Docker Hub image.
						Building a custom Docker container is simple with the use of a Dockerfile.
					</section>
					<section>
						Example:
						<pre><code data-trim data-noescape>
							$ touch Dockerfile
							$ vim Dockerfile
							
							FROM ubuntu

							CMD ["echo hello from container!"]

							$ docker build

						</code></pre>
					</section>
					<section>
						Other useful command tags for Dockerfile:
						<pre><code data-trim data-noescape>
							ADD
							EXPOSE
							RUN
						</code></pre>
						complete list at [docs.docker.com/engine/reference/builder](https://docs.docker.com/engine/reference/builder/)
					</section>
					<section>
						With Dockerfiles we can create custom Docker containers.
					</section>
					<section>
						Problem: creating, running, and managing containers one-by-one can be complicated.
					</section>
					<section>
						*Docker Compose* solves such problems.
					</section>
					<section data-background-image="./ht/imgs/compose-logo.png" data-background-size="500px">
						Docker Compose
					</section>
					<section>
						Compose is a tool for defining and running multi-container Docker applications.
					</section>
					<section>
						Multiple containers are able to communicate over a virtual network
						<pre><code data-trim data-noescape>
							$ touch composefile.yml
							$ vim composefile.yml
						</code></pre>
					</section>
					<section>
						composefile.yml
						<pre class="stretch"><code data-trim data-noescape>
						version: '2'
						services:
							# Config Servers
							cfg1:
								image: mongo:3.0.6
								ports:
									- "9091:27017"
								volumes:
									- ./docker-volumes/mongocluster/cfg1:/data/configdb
								command: mongod --configsvr --noauth --port 27017
							cfg2:
								image: mongo:3.0.6
								ports:
									- "9092:27017"
								volumes:
									- ./docker-volumes/mongocluster/cfg1:/data/configdb 
								command: mongod --configsvr --noauth --port 27017
						</code></pre>
					</section>
					<section>
						To create Docker containers listed in the composefile:
						<pre><code data-trim data-noescape>
							$ docker-compose -f composefile.yml up
						</code></pre>
					</section>
					<section>
						To destroy Docker containers listed in the composefile:
						<pre><code data-trim data-noescape>
							$ docker-compose -f composefile.yml down
						</code></pre>
					</section>
					<section>
						With Docker Compose we are now able to create multiple intercommunicating containers applications
					</section>
					</script>
				</section>

				<section>
					Combining MongoDB and Docker Compose
				</section>

				<section data-markdown>
					<script type="text/template">
						<section>
							With this knowledge base, let's remind ourselves the Plan of Attack
						</section>
						<section>
							We can use multiple **Docker** containers running **MongoDB** networked together to create our cluster [2]
						</section>
						<section data-background-image="./ht/imgs/plan-of-attack3.png" data-background-size="800px">
						</section>
						<section>
							Our pseudo composefile.yml for 2 shards and 3 replicas might look something like this:
						<pre class="stretch"><code data-trim data-noescape>
						version: '2'
						services:
							# Config Servers
							cfg1:
							cfg2:
							cfg3:

							# shards and replicas
							sh1_repl1: 				# sh1
							sh1_repl2:
							sh1_repl3:

							sh2_repl1: 				# sh2
							sh2_repl2:
							sh2_repl3:

							# Router
							router:
						</code></pre>
						</section>
						<section>
							Problem: We are still hardcoding the cluster size on the Docker Compose file.
						</section>
						<section>
							Solution? Create a script.
						</section>
						<section>
							1) Script should write the dockercompose.yml file according to user specs
						</section>
						<section>
							2) Run the dockercompose.yml and configure the MongoDB containers to work in sharded mode.
						</section>
						<section>
							What we want:
							<pre><code data-trim>
								$ script databasename collectionname shards replicas port
							</code></pre>
						</section>
						<section>
							Demo
						</section>
						<section>
							Sharding step-by-step
						</section>
					</script>
				</section>
				<!-- misc -->
			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
		<script src="js/reveal.js"></script>

		<script>
			// More info https://github.com/hakimel/reveal.js#configuration
			Reveal.initialize({
				history: true,

				// More info https://github.com/hakimel/reveal.js#dependencies
				dependencies: [
					{ src: 'plugin/markdown/marked.js' },
					{ src: 'plugin/markdown/markdown.js' },
					{ src: 'plugin/notes/notes.js', async: true },
					{ src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } }
				]
			});
		</script>
	</body>
</html>
